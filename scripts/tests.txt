Test files:

================================================================================

FILE NAME: tests/conftest.py

# tests/conftest.py

import pytest
import sys
import pandas as pd
import os

# Add the project root to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app, db


@pytest.fixture(scope='function')
def app():
    """
    Create and configure a new app instance for each test.
    """
    # Set the environment variable to 'testing'
    os.environ['FLASK_ENV'] = 'testing'
    
    # Create the Flask app with testing configuration
    app = create_app('testing')
    
    # Establish an application context
    with app.app_context():
        # Create the database and the database tables
        db.create_all()
        yield app
        # Drop the database tables after the test
        db.session.remove()
        db.drop_all()


@pytest.fixture(scope='function')
def client(app):
    """
    Create a test client for the app.
    """
    return app.test_client()


@pytest.fixture(scope='function')
def runner(app):
    """
    Create a CLI runner for the app.
    """
    return app.test_cli_runner()


# Import fixtures from fixtures.py
from .fixtures import (
    populate_test_db,
    sample_df_single_column,    
    sample_df_multiple_columns,
    create_seriesgroup_and_type  # Updated fixture name
)

================================================================================

FILE NAME: tests/test_timeseries.py

# tests/test_timeseries.py

import pytest
import datetime
import pandas as pd
from app.models import TimeSeries, DataPoint, SeriesGroup, TimeSeriesType
from app import db  # Import db for database operations


def test_from_dataframe_single_column(
    app,
    sample_df_single_column,
    create_seriesgroup_and_type  # Updated fixture name
):
    """
    Test that from_dataframe handles a single-column DataFrame and returns one TimeSeries.
    """
    seriesgroup, tstype = create_seriesgroup_and_type

    with app.app_context():
        ts_obj = TimeSeries.from_dataframe(
            df=sample_df_single_column,
            series_groups=[seriesgroup],  # Pass as a list of objects
            time_series_type=tstype  # Assign the object directly
        )

        # Expect a single TimeSeries (not a list)
        assert isinstance(ts_obj, TimeSeries), "Should return a single TimeSeries object."
        assert ts_obj.name == "price", "TimeSeries name should match the DataFrame column name."
        assert len(ts_obj.data_points) == 252, "TimeSeries should have 252 DataPoints."

        # Check the data points
        for i, dp in enumerate(ts_obj.data_points):
            expected_date = sample_df_single_column.index[i].date()
            expected_value = sample_df_single_column["price"].iloc[i]
            assert dp.date.date() == expected_date, f"Expected date {expected_date}, got {dp.date}"
            assert dp.value == expected_value, f"Expected value {expected_value}, got {dp.value}"


def test_from_dataframe_single_column_with_seriesgroup_and_tstype(
    app,
    sample_df_single_column,
    create_seriesgroup_and_type  # Updated fixture name
):
    """
    Test that from_dataframe handles a single-column DataFrame and returns one TimeSeries.
    """
    seriesgroup, tstype = create_seriesgroup_and_type

    with app.app_context():
        ts_obj = TimeSeries.from_dataframe(
            df=sample_df_single_column,
            series_groups=[seriesgroup],  # Pass as a list of objects
            time_series_type=tstype  # Assign the object directly
        )

        # Expect a single TimeSeries (not a list)
        assert isinstance(ts_obj, TimeSeries), "Should return a single TimeSeries object."
        assert ts_obj.name == "price", "TimeSeries name should match the DataFrame column name."
        assert len(ts_obj.data_points) == 252, "TimeSeries should have 252 DataPoints."

        # Check the data points
        for i, dp in enumerate(ts_obj.data_points):
            expected_date = sample_df_single_column.index[i].date()
            expected_value = sample_df_single_column["price"].iloc[i]
            assert dp.date.date() == expected_date, f"Expected date {expected_date}, got {dp.date}"
            assert dp.value == expected_value, f"Expected value {expected_value}, got {dp.value}"


def test_from_dataframe_single_column_with_date_as_column(
    app,
    sample_df_single_column,
    create_seriesgroup_and_type  # Updated fixture name
):
    """
    Test that from_dataframe handles a single-column DataFrame and returns one TimeSeries with a specified date column.
    """
    seriesgroup, tstype = create_seriesgroup_and_type

    sample_df = sample_df_single_column.copy()
    sample_df["Datetime"] = sample_df.index
    sample_df = sample_df.reset_index(drop=True)

    with app.app_context():
        ts_obj = TimeSeries.from_dataframe(
            df=sample_df,
            series_groups=[seriesgroup],  # Pass as a list of objects
            time_series_type=tstype,  # Assign the object directly
            date_column="Datetime"
        )

        # Expect a single TimeSeries (not a list)
        assert isinstance(ts_obj, TimeSeries), "Should return a single TimeSeries object."
        assert ts_obj.name == "price", "TimeSeries name should match the DataFrame column name."
        assert len(ts_obj.data_points) == 252, "TimeSeries should have 252 DataPoints."

        # Check the data points
        for i, dp in enumerate(ts_obj.data_points):
            expected_date = sample_df["Datetime"][i].date()
            expected_value = sample_df["price"].iloc[i]
            assert dp.date.date() == expected_date, f"Expected date {expected_date}, got {dp.date}"
            assert dp.value == expected_value, f"Expected value {expected_value}, got {dp.value}"


def test_from_dataframe_multi_column(
    app,
    sample_df_multiple_columns,
    create_seriesgroup_and_type  # Updated fixture name
):
    """
    Test that from_dataframe handles a multi-column DataFrame and returns multiple TimeSeries.
    """
    seriesgroup, tstype = create_seriesgroup_and_type
    num_columns = len(sample_df_multiple_columns.columns)

    with app.app_context():
        # Since there are multiple columns, provide a list of SeriesGroup objects
        # For simplicity, using the same SeriesGroup for all columns
        series_groups = [seriesgroup for _ in range(num_columns)]

        ts_objs = TimeSeries.from_dataframe(
            df=sample_df_multiple_columns,
            series_groups=series_groups,  # Pass as a list of objects
            time_series_type=tstype  # Assign the object directly
        )

        # Expect a list of TimeSeries objects
        assert isinstance(ts_objs, list), "Should return a list of TimeSeries objects."
        assert len(ts_objs) == num_columns, "Should return one TimeSeries per column."
        assert all(isinstance(ts, TimeSeries) for ts in ts_objs), "All elements should be TimeSeries objects."
        assert ts_objs[0].name == "price", "First TimeSeries name should match the first DataFrame column name."


def test_to_dataframe_multi_column(
    app,
    sample_df_multiple_columns,
    create_seriesgroup_and_type  # Updated fixture name
):
    """
    Test that from_dataframe handles a multi-column DataFrame and the resulting TimeSeries can be converted back to DataFrame.
    """
    seriesgroup, tstype = create_seriesgroup_and_type

    with app.app_context():
        # Provide a list of SeriesGroup objects matching the number of columns
        num_columns = len(sample_df_multiple_columns.columns)
        series_groups = [seriesgroup for _ in range(num_columns)]

        ts_objs = TimeSeries.from_dataframe(
            df=sample_df_multiple_columns,
            series_groups=series_groups,  # Pass as a list of objects
            time_series_type=tstype  # Assign the object directly
        )
        for ts_obj in ts_objs:
            ts_dataframe = ts_obj.to_dataframe()
            assert isinstance(ts_dataframe, pd.DataFrame), "Should return a DataFrame."
            assert len(ts_dataframe.index) == len(sample_df_multiple_columns.index), "DataFrame index length should match input length."


def test_to_dataframe_single_column(
    app,
    sample_df_single_column,
    create_seriesgroup_and_type  # Updated fixture name
):
    """
    Test that from_dataframe handles a single-column DataFrame and returns one TimeSeries, which can be converted back to DataFrame.
    """
    seriesgroup, tstype = create_seriesgroup_and_type

    with app.app_context():
        ts_obj = TimeSeries.from_dataframe(
            df=sample_df_single_column,
            series_groups=[seriesgroup],  # Pass as a list of objects
            time_series_type=tstype  # Assign the object directly
        )

        ts_dataframe = ts_obj.to_dataframe()
        assert isinstance(ts_dataframe, pd.DataFrame), "Should return a DataFrame."
        assert len(ts_dataframe.index) == len(sample_df_single_column.index), "DataFrame index length should match input length."
        assert list(ts_dataframe.columns) == ["price"], "DataFrame columns should match the input DataFrame."
        for i in range(5):
            assert ts_dataframe.iloc[i, 0] == sample_df_single_column.iloc[i, 0], "DataFrame values should match the input DataFrame."

================================================================================

FILE NAME: tests/test_initial_database_population.py

# tests/test_initial_database_population.py

import pytest
from app.models import SeriesGroup, TimeSeriesType, TimeSeries, DataPoint
import datetime

def test_initial_population(populate_test_db):
    """
    Test the initial population of the test database by verifying the created entries.
    """
    # Populate the database with 3 SeriesGroups and 5 data points per time series
    populate_test_db(num_seriesgroups=3, num_data_points=5, start_date="2024-01-01")

    # Verify the number of entries created
    assert SeriesGroup.query.count() == 3, "There should be exactly 3 SeriesGroups."
    assert TimeSeriesType.query.count() == 1, "There should be exactly one TimeSeriesType."
    assert TimeSeries.query.count() == 3, "There should be exactly three TimeSeries."
    assert DataPoint.query.count() == 15, "Each TimeSeries should have 5 DataPoints."

    # Retrieve and check the SeriesGroups
    for sg in SeriesGroup.query.all():
        assert len(sg.name) == 3, f"SeriesGroup name '{sg.name}' should have exactly three characters."
        assert sg.description.endswith("Description"), f"SeriesGroup description mismatch for '{sg.name}'."
        assert sg.series_group_code is not None and len(sg.series_group_code) == 5, (
            f"SeriesGroup '{sg.name}' should have a valid series_group_code of length 5."
        )

    # Retrieve and check the TimeSeriesType
    time_series_type = TimeSeriesType.query.first()
    assert time_series_type.name == 'Price', "TimeSeriesType name should be 'Price'."
    assert time_series_type.description == 'Price Time Series', "TimeSeriesType description mismatch."

    # Retrieve and check the TimeSeries and their DataPoints
    for time_series in TimeSeries.query.all():
        assert len(time_series.name) > 0, "TimeSeries name should not be empty."
        assert time_series.type_id == time_series_type.id, "TimeSeries type_id mismatch."

        # Ensure each TimeSeries is associated with at least one SeriesGroup
        associated_sg_ids = [sg.id for sg in time_series.series_groups]
        assert len(associated_sg_ids) >= 1, (
            f"TimeSeries '{time_series.name}' should be associated with at least one SeriesGroup."
        )

        data_points = time_series.data_points
        assert len(data_points) == 5, f"TimeSeries '{time_series.name}' should have exactly 5 DataPoints."

        # Verify the DataPoints
        start_date = datetime.date(2024, 1, 1)
        for i, dp in enumerate(data_points):
            expected_date = start_date + datetime.timedelta(days=i)
            assert dp.date == expected_date, (
                f"DataPoint date mismatch: expected {expected_date}, got {dp.date}."
            )
            assert isinstance(dp.value, float), "DataPoint 'value' should be a float."
            assert dp.time_series_id == time_series.id, (
                f"DataPoint time_series_id mismatch for DataPoint ID {dp.id}."
            )

            # Check `date_release` conditionally
            if dp.date_release:
                expected_release_date = dp.date + datetime.timedelta(days=1)
                assert dp.date_release == expected_release_date, (
                    f"DataPoint 'date_release' mismatch: expected {expected_release_date}, got {dp.date_release}."
                )

================================================================================

FILE NAME: tests/__init__.py



================================================================================

FILE NAME: tests/test_save_models.py

# tests/test_save_models.py

import pytest
import datetime
from app import db
from app.models import SeriesGroup, TimeSeriesType, TimeSeries, DataPoint

def test_save_seriesgroup(app):
    """
    Test saving a standalone SeriesGroup to the database using the `save` method.
    """
    seriesgroup = SeriesGroup(name="SG1", description="Test SeriesGroup", series_code="SG001")
    seriesgroup.save()  # or db.session.add(seriesgroup); db.session.commit()

    assert seriesgroup.id is not None, "SeriesGroup ID should be generated after saving."
    assert SeriesGroup.query.count() == 1, "Exactly one SeriesGroup should exist in the database."

    retrieved = SeriesGroup.query.first()
    assert retrieved.name == "SG1", "Retrieved SeriesGroup name should match 'SG1'."
    assert retrieved.description == "Test SeriesGroup", "SeriesGroup description should match."
    assert retrieved.series_code == "SG001", "SeriesGroup series_code should match 'SG001'."

def test_save_time_series_type(app):
    """
    Test saving a TimeSeriesType to the database using the `save` method.
    """
    tst = TimeSeriesType(name="Price", description="Price Time Series")
    tst.save()

    assert tst.id is not None, "TimeSeriesType ID should be set after saving."
    assert TimeSeriesType.query.count() == 1, "Exactly one TimeSeriesType should exist."

    retrieved = TimeSeriesType.query.first()
    assert retrieved.name == "Price", "Retrieved name should be 'Price'."
    assert retrieved.description == "Price Time Series", "TimeSeriesType description mismatch."

def test_save_time_series_with_dependencies(app):
    """
    Test saving a TimeSeries that depends on a SeriesGroup and a TimeSeriesType.
    Verifies the parent objects can be saved together if they're new.
    """
    seriesgroup = SeriesGroup(name="SG2", description="Second SeriesGroup", series_code="SG002")
    tstype = TimeSeriesType(name="Volume", description="Volume Time Series")

    ts = TimeSeries(
        name="TS-Test",
        time_series_type=tstype  # Correct: Assign the object, not the ID
    )
    ts.series_groups.append(seriesgroup)

    ts.save()  # Should save ts, seriesgroup & tstype, too.

    # Verify TimeSeries
    assert ts.id is not None, "TimeSeries ID should be set after saving."
    assert TimeSeries.query.count() == 1, "One TimeSeries should exist."

    # Verify SeriesGroup
    assert seriesgroup.id is not None, "SeriesGroup ID should be set after saving TimeSeries."
    assert SeriesGroup.query.count() == 1, "One SeriesGroup should exist."

    # Verify TimeSeriesType
    assert tstype.id is not None, "TimeSeriesType ID should be set after saving TimeSeries."
    assert TimeSeriesType.query.count() == 1, "One TimeSeriesType should exist."
    
    # Additionally, check that the association is correct
    retrieved_ts = TimeSeries.query.first()
    associated_sgs = retrieved_ts.series_groups.all()
    assert len(associated_sgs) == 1, "TimeSeries should be associated with one SeriesGroup."
    assert associated_sgs[0].id == seriesgroup.id, "Associated SeriesGroup should match the created one."

def test_save_data_points_with_timeseries(app):
    """
    Test saving a TimeSeries along with multiple DataPoints.
    Ensures child DataPoints are also saved.
    """
    seriesgroup = SeriesGroup(name="SG3", description="Third SeriesGroup", series_code="SG003")
    tstype = TimeSeriesType(name="Price", description="Price Time Series")

    ts = TimeSeries(name="TS-DataPoints", time_series_type=tstype)  # Correct assignment
    ts.series_groups.append(seriesgroup)

    dp1 = DataPoint(date=datetime.date(2025, 1, 10), value=4000.0)
    dp2 = DataPoint(date=datetime.date(2025, 1, 11), value=4050.5)
    ts.data_points.extend([dp1, dp2])

    ts.save()  # Should save ts, seriesgroup, tstype, and dp1/dp2

    # Verify
    assert TimeSeries.query.count() == 1, "One TimeSeries should be saved."
    assert DataPoint.query.count() == 2, "Two DataPoints should be saved."

    retrieved_ts = TimeSeries.query.first()
    assert len(retrieved_ts.data_points) == 2, "Retrieved TimeSeries should have 2 DataPoints."
    
    # Verify SeriesGroup association
    associated_sgs = retrieved_ts.series_groups.all()
    assert len(associated_sgs) == 1, "TimeSeries should be associated with one SeriesGroup."
    assert associated_sgs[0].id == seriesgroup.id, "Associated SeriesGroup should match the created one."

def test_save_datapoint_alone_with_parents(app):
    """
    Test saving a single DataPoint that has a reference to a new TimeSeries,
    which references a new SeriesGroup and TimeSeriesType. All should be saved.
    """
    seriesgroup = SeriesGroup(name="SG4", description="Fourth SeriesGroup", series_code="SG004")
    tstype = TimeSeriesType(name="Bids", description="Bid Time Series")
    ts = TimeSeries(name="TS-Bids", time_series_type=tstype)  # Correct assignment
    ts.series_groups.append(seriesgroup)

    dp = DataPoint(date=datetime.date(2025, 1, 12), value=5001.5, time_series=ts)
    dp.save()  # Should cascade and save dp, ts, seriesgroup, tstype

    assert dp.id is not None, "DataPoint should have an ID after saving."
    assert seriesgroup.id is not None, "SeriesGroup should be saved."
    assert tstype.id is not None, "TimeSeriesType should be saved."
    assert ts.id is not None, "TimeSeries should be saved."

    # Verify counts
    assert SeriesGroup.query.count() == 1, "Exactly one SeriesGroup should be in DB."
    assert TimeSeriesType.query.count() == 1, "Exactly one TimeSeriesType should be in DB."
    assert TimeSeries.query.count() == 1, "Exactly one TimeSeries should be in DB."
    assert DataPoint.query.count() == 1, "Exactly one DataPoint should be in DB."

    # Optionally, verify the association
    retrieved_ts = TimeSeries.query.first()
    associated_sgs = retrieved_ts.series_groups.all()
    assert len(associated_sgs) == 1, "TimeSeries should be associated with one SeriesGroup."
    assert associated_sgs[0].id == seriesgroup.id, "Associated SeriesGroup should match the created one."

def test_save_multiple_objects_in_one_session(app):
    """
    Test saving multiple objects in one transaction without committing until the end.
    """
    seriesgroup = SeriesGroup(name="SG5", description="Fifth SeriesGroup", series_code="SG005")
    tstype = TimeSeriesType(name="Spread", description="Spread Time Series")
    ts = TimeSeries(name="TS-Spread", time_series_type=tstype)  # Correct assignment
    ts.series_groups.append(seriesgroup)
    dp = DataPoint(date=datetime.date(2025, 1, 13), value=3999.9, time_series=ts)

    # Manually pass commit=False to gather them in the session, then commit once
    seriesgroup.save(commit=False)
    tstype.save(commit=False)
    ts.save(commit=False)
    dp.save(commit=False)

    # Now commit explicitly
    db.session.commit()

    # Verify
    assert SeriesGroup.query.count() == 1, "Exactly one SeriesGroup should be saved."
    assert TimeSeriesType.query.count() == 1, "Exactly one TimeSeriesType should be saved."
    assert TimeSeries.query.count() == 1, "Exactly one TimeSeries should be saved."
    assert DataPoint.query.count() == 1, "Exactly one DataPoint should be saved."

    retrieved_dp = DataPoint.query.first()
    assert retrieved_dp.value == 3999.9, "DataPoint value should be as assigned."
    assert retrieved_dp.time_series.name == "TS-Spread", "DataPoint should link to the correct TimeSeries."

================================================================================

FILE NAME: tests/fixtures.py

# tests/fixtures.py

import pytest
import random
import string
from app.models import SeriesGroup, TimeSeriesType, TimeSeries, DataPoint
import datetime
import pandas as pd
from app import db
import numpy as np


@pytest.fixture
def create_seriesgroup_and_type(app):
    """
    Fixture to create a SeriesGroup and a TimeSeriesType.
    Returns the objects themselves.
    """
    seriesgroup = SeriesGroup(name="SG_Test", description="Test SeriesGroup", series_group_code="SG999")
    tstype = TimeSeriesType(name="TestType", description="Test TimeSeriesType")
    db.session.add_all([seriesgroup, tstype])
    db.session.commit()
    return seriesgroup, tstype

@pytest.fixture
def populate_test_db(app):
    """
    Fixture to populate the test database with initial data.
    Accepts parameters for the number of series groups and data points per time series.
    """

    def _populate_test_db(num_seriesgroups=3, num_data_points=5, start_date=datetime.date(2024, 1, 1)):
        """
        Internal function to populate the test database.
        
        Args:
            num_seriesgroups (int): Number of SeriesGroups to create.
            num_data_points (int): Number of data points per time series.
            start_date (date or str): Start date for generating data points.
        """

        # Convert `start_date` to a `datetime.date` object if it's a string
        if isinstance(start_date, str):
            start_date = datetime.datetime.strptime(start_date, "%Y-%m-%d").date()

        def generate_random_name(length=3):
            """Generate a random name with the specified length."""
            return ''.join(random.choices(string.ascii_uppercase, k=length))

        def create_data_points(time_series_id, num_points, start_date):
            """Create random data points for a given time series."""
            data_points = []
            for i in range(num_points):
                date = start_date + datetime.timedelta(days=i)
                value = round(random.uniform(1000.0, 5000.0), 2)  # Random value between 1000 and 5000

                # Randomly decide whether to assign a `date_release` or leave it as None
                if random.choice([True, False]):
                    date_release = date + datetime.timedelta(days=1)
                else:
                    date_release = None

                data_point = DataPoint(
                    date=date,
                    value=value,
                    date_release=date_release,
                    time_series_id=time_series_id
                )
                data_points.append(data_point)
            return data_points

        with app.app_context():
            # Set a fixed random seed for reproducibility
            random.seed(42)

            # Create a TimeSeriesType
            time_series_type = TimeSeriesType(name='Price', description='Price Time Series')
            db.session.add(time_series_type)
            db.session.commit()

            # Generate the specified number of SeriesGroups and time series
            for _ in range(num_seriesgroups):
                # Create a random SeriesGroup
                seriesgroup_name = generate_random_name()
                series_group_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))
                seriesgroup = SeriesGroup(
                    name=seriesgroup_name,
                    description=f"{seriesgroup_name} Description",
                    series_group_code=series_group_code
                )
                db.session.add(seriesgroup)
                db.session.commit()

                # Create a random TimeSeries for the SeriesGroup
                time_series_name = generate_random_name()
                time_series = TimeSeries(
                    name=f"{seriesgroup_name} {time_series_name}",
                    type_id=time_series_type.id,
                    delta_type='pct'  # Assuming default or desired value
                )
                db.session.add(time_series)
                db.session.commit()

                # Associate TimeSeries with SeriesGroup
                seriesgroup.series.append(time_series)
                db.session.commit()

                # Create random data points for the time series
                data_points = create_data_points(time_series.id, num_data_points, start_date)
                db.session.add_all(data_points)
                db.session.commit()

    return _populate_test_db

@pytest.fixture
def sample_df_single_column():
    """
    Returns a single-column DataFrame (with a DateTimeIndex).
    """
    rng = np.random.default_rng(seed=42)
    returns = rng.normal(0.0001, 0.01, 252)
    prices = 100 * (1 + np.cumsum(returns))
    dates = pd.date_range("2025-01-01", periods=252, freq="D")
    return pd.DataFrame({"price": prices}, index=dates)

@pytest.fixture
def sample_df_multiple_columns():
    """
    Returns a multi-column DataFrame (with a DateTimeIndex).
    """
    rng = np.random.default_rng(seed=42)
    returns = rng.normal(0.0001, 0.01, 252)
    prices = 100 * (1 + np.cumsum(returns))
    volumes = rng.integers(1000, 10000, 252)
    dates = pd.date_range("2025-01-01", periods=252, freq="D")
    return pd.DataFrame({"price": prices, "volume": volumes}, index=dates)

================================================================================

